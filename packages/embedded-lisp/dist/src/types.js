"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const env_1 = require("./env");
function equals(a, b, strict) {
    if (strict && a.type !== b.type) {
        return false;
    }
    if (a.type === 4 && b.type === 4) {
        return true;
    }
    if (isSeq(a) && isSeq(b)) {
        return listEquals(a.list, b.list);
    }
    if (a.type === 9 && b.type === 9) {
        if (a.keywordMap.size !== b.keywordMap.size) {
            return false;
        }
        if (Object.keys(a.stringMap).length !== Object.keys(b.stringMap).length) {
            return false;
        }
        for (const [aK, aV] of a.entries()) {
            if (aK.type !== 3 && aK.type !== 7) {
                throw new Error(`unexpected symbol: ${aK.type}, expected: string or keyword`);
            }
            const bV = b.get(aK);
            if (aV.type === 4 && bV.type === 4) {
                continue;
            }
            if (!equals(aV, bV)) {
                return false;
            }
        }
        return true;
    }
    if ((a.type === 2 && b.type === 2)
        || (a.type === 3 && b.type === 3)
        || (a.type === 5 && b.type === 5)
        || (a.type === 6 && b.type === 6)
        || (a.type === 7 && b.type === 7)) {
        return a.v === b.v;
    }
    return false;
    function listEquals(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (!equals(a[i], b[i], strict)) {
                return false;
            }
        }
        return true;
    }
}
exports.equals = equals;
function isSeq(ast) {
    return ast.type === 1 || ast.type === 8;
}
exports.isSeq = isSeq;
function isAST(v) {
    return !!v.type;
}
exports.isAST = isAST;
class MalList {
    constructor(list) {
        this.list = list;
        this.type = 1;
    }
    withMeta(meta) {
        const v = new MalList(this.list);
        v.meta = meta;
        return v;
    }
}
exports.MalList = MalList;
class MalNumber {
    constructor(v) {
        this.v = v;
        this.type = 2;
    }
    withMeta(meta) {
        const v = new MalNumber(this.v);
        v.meta = meta;
        return v;
    }
}
exports.MalNumber = MalNumber;
class MalString {
    constructor(v) {
        this.v = v;
        this.type = 3;
    }
    withMeta(meta) {
        const v = new MalString(this.v);
        v.meta = meta;
        return v;
    }
}
exports.MalString = MalString;
class MalNil {
    constructor() {
        this.type = 4;
    }
    static get instance() {
        if (this._instance) {
            return this._instance;
        }
        this._instance = new MalNil();
        return this._instance;
    }
    withMeta(_meta) {
        throw new Error(`not supported`);
    }
}
exports.MalNil = MalNil;
class MalBoolean {
    constructor(v) {
        this.v = v;
        this.type = 5;
    }
    withMeta(meta) {
        const v = new MalBoolean(this.v);
        v.meta = meta;
        return v;
    }
}
exports.MalBoolean = MalBoolean;
class MalSymbol {
    constructor(v) {
        this.v = v;
        this.type = 6;
    }
    static get(name) {
        const sym = Symbol.for(name);
        let token = this.map.get(sym);
        if (token) {
            return token;
        }
        token = new MalSymbol(name);
        this.map.set(sym, token);
        return token;
    }
    withMeta(_meta) {
        throw new Error(`not supported`);
    }
}
MalSymbol.map = new Map();
exports.MalSymbol = MalSymbol;
class MalKeyword {
    constructor(v) {
        this.v = v;
        this.type = 7;
    }
    static get(name) {
        const sym = Symbol.for(name);
        let token = this.map.get(sym);
        if (token) {
            return token;
        }
        token = new MalKeyword(name);
        this.map.set(sym, token);
        return token;
    }
    withMeta(_meta) {
        throw new Error(`not supported`);
    }
}
MalKeyword.map = new Map();
exports.MalKeyword = MalKeyword;
class MalVector {
    constructor(list) {
        this.list = list;
        this.type = 8;
    }
    withMeta(meta) {
        const v = new MalVector(this.list);
        v.meta = meta;
        return v;
    }
}
exports.MalVector = MalVector;
class MalHashMap {
    constructor(list) {
        this.type = 9;
        this.stringMap = {};
        this.keywordMap = new Map();
        while (list.length !== 0) {
            const key = list.shift();
            const value = list.shift();
            if (value == null) {
                throw new Error("unexpected hash length");
            }
            if (key.type === 7) {
                this.keywordMap.set(key, value);
            }
            else if (key.type === 3) {
                this.stringMap[key.v] = value;
            }
            else {
                throw new Error(`unexpected key symbol: ${key.type}, expected: keyword or string`);
            }
        }
    }
    withMeta(meta) {
        const v = this.assoc([]);
        v.meta = meta;
        return v;
    }
    has(key) {
        if (key.type === 7) {
            return !!this.keywordMap.get(key);
        }
        return !!this.stringMap[key.v];
    }
    get(key) {
        if (key.type === 7) {
            return this.keywordMap.get(key) || MalNil.instance;
        }
        return this.stringMap[key.v] || MalNil.instance;
    }
    entries() {
        const list = [];
        this.keywordMap.forEach((v, k) => {
            list.push([k, v]);
        });
        Object.keys(this.stringMap).forEach(v => list.push([new MalString(v), this.stringMap[v]]));
        return list;
    }
    keys() {
        const list = [];
        this.keywordMap.forEach((_v, k) => {
            list.push(k);
        });
        Object.keys(this.stringMap).forEach(v => list.push(new MalString(v)));
        return list;
    }
    vals() {
        const list = [];
        this.keywordMap.forEach(v => {
            list.push(v);
        });
        Object.keys(this.stringMap).forEach(v => list.push(this.stringMap[v]));
        return list;
    }
    assoc(args) {
        const list = [];
        this.keywordMap.forEach((value, key) => {
            list.push(key);
            list.push(value);
        });
        Object.keys(this.stringMap).forEach(keyStr => {
            list.push(new MalString(keyStr));
            list.push(this.stringMap[keyStr]);
        });
        return new MalHashMap(list.concat(args));
    }
    dissoc(args) {
        const newHashMap = this.assoc([]);
        args.forEach(arg => {
            if (arg.type === 3) {
                delete newHashMap.stringMap[arg.v];
            }
            else if (arg.type === 7) {
                newHashMap.keywordMap.delete(arg);
            }
            else {
                throw new Error(`unexpected symbol: ${arg.type}, expected: keyword or string`);
            }
        });
        return newHashMap;
    }
}
exports.MalHashMap = MalHashMap;
class MalFunction {
    constructor() {
        this.type = 10;
    }
    static fromLisp(evalMal, env, params, bodyAst) {
        const f = new MalFunction();
        f.func = (...args) => evalMal(bodyAst, new env_1.Env(env, params, checkUndefined(args)));
        f.env = env;
        f.params = params;
        f.ast = bodyAst;
        f.isMacro = false;
        return f;
        function checkUndefined(args) {
            return args.map(arg => {
                if (!arg) {
                    throw new Error(`undefined argument`);
                }
                return arg;
            });
        }
    }
    static fromBootstrap(func) {
        const f = new MalFunction();
        f.func = func;
        f.isMacro = false;
        return f;
    }
    withMeta(meta) {
        const f = new MalFunction();
        f.func = this.func;
        f.ast = this.ast;
        f.env = this.env;
        f.params = this.params;
        f.isMacro = this.isMacro;
        f.meta = meta;
        return f;
    }
    newEnv(args) {
        return new env_1.Env(this.env, this.params, args);
    }
}
exports.MalFunction = MalFunction;
class MalAtom {
    constructor(v) {
        this.v = v;
        this.type = 11;
    }
    withMeta(meta) {
        const v = new MalAtom(this.v);
        v.meta = meta;
        return v;
    }
}
exports.MalAtom = MalAtom;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXMuanMiLCJzb3VyY2VSb290IjoiLi8iLCJzb3VyY2VzIjpbInNyYy90eXBlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLCtCQUE0QjtBQWtCNUIsU0FBZ0IsTUFBTSxDQUFDLENBQVUsRUFBRSxDQUFVLEVBQUUsTUFBZ0I7SUFDM0QsSUFBSSxNQUFNLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFFO1FBQzdCLE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0lBRUQsSUFBSSxDQUFDLENBQUMsSUFBSSxNQUFhLElBQUksQ0FBQyxDQUFDLElBQUksTUFBYSxFQUFFO1FBQzVDLE9BQU8sSUFBSSxDQUFDO0tBQ2Y7SUFDRCxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDdEIsT0FBTyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDckM7SUFDRCxJQUFJLENBQUMsQ0FBQyxJQUFJLE1BQWlCLElBQUksQ0FBQyxDQUFDLElBQUksTUFBaUIsRUFBRTtRQUNwRCxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFO1lBQ3pDLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBQ0QsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFNLEtBQUssTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxFQUFFO1lBQ3JFLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBQ0QsS0FBSyxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUNoQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLE1BQWdCLElBQUksRUFBRSxDQUFDLElBQUksTUFB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